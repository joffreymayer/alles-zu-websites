# Webdevelopment

Hier liste ich allgemein Nützliches & Begriffe zum Thema "WebDev".

## Synonyme 

- **Backend** // Server
- **Constraint** // Rule // Annahme(n)
- **(above the) Fold** // Viewport // Alles, was beim Laden einer HTML-Seite "visible" wird auf dem Screen eines Users
- **Store data (for example, in an array)** // present data
- **Toggle** // Ein- & Ausschaltknopf
- **user agent** // browser 
- **Weiterleitung** // forwarding // routing(?)
- **Parse** // In der Umwandlung `A --> B`, ist mit dem **<u>Pfeil</u>** das "parsen" gemeint! 
  - <u>Beispiel</u>: Umwandlung - beispielsweise der HTML-Sprache - in die Dokumentstruktur "DOM", damit diese - via einem Renderer - visuell dargestellt werden kann im Browser.
- **DPR** // device-pixel-ratio


## Definitionen

- **Bandwidth**: Bandwidth in website hosting is the amount of data your website can transfer to your users in a given amount of time.
  - <u>Why is this important</u>: When you deal with **images, especially for smaller screens, such as phones**. The problem here is, that a **very big images can take alot of bandwidth (up to 60%)**. As a consequence, it slows down the performance of the site, which is the most important thing Google cares about when ranking websites!
- **CRUD**: This is an acronym, which refers to the **4 functions, that are considered necessary to implement a persistent storage application**:
  - **<u>c</u>**reat
  - **<u>r</u>**ead, 
  - **<u>u</u>**pdate and 
  - **<u>d</u>**elete.
    - <u>Example of a CRUD Application</u>: Facebook, Instagram or TikTok, because each of those apps lets you:
      - **C-** Create posts, videos, comments, likes etc. 
      - **R-** Read posts, view pictures, see like counts, see followers of other users etc. 
      - **U-** Edit posts, pictures, comments, profiles and update them etc. and finally 
      - **D-** Delete posts, pictures, comments, videos etc.
- **Dependency // Dependencies**: A dependency is a **third-party bit of software** that was probably written by someone else and ideally solves a single problem for you. A web project can have any number of dependencies, ranging from none to many, and **your dependencies might include sub-dependencies that you didn't explicitly install** — your dependencies may have their own dependencies.
  - <u>Example</u>: A useful dependency that your project might need is some **code to calculate relative dates as human-readable text**. You could certainly code this yourself, but there's a strong chance that someone else has already solved this problem 
  — <u>Vorteil 1</u>: *Why waste time reinventing the wheel?*
  - <u>Vorteil 2</u>:  Moreover, a reliable third-party dependency will likely have been tested in a lot of different situations, making it **more robust and cross-browser compatible** than your own solution.
- **Package Manager**: **A package manager is a system that will manage your project dependencies**. 
  - <u>Example</u>: When you use a dependenciy // third-party code, you will need to update it, if a new version gets released. If you have MANY dependencies, then you will need a *package manager* such as **`npm`**, because it will guarantee that the *updated* code is added and the *old one* is removed cleanly.
  - <u>Why should you use a packet manager?</u>: _In theory_, you may <u>not</u> need a package manager and you could manually download and store your project dependencies, but a package manager will seamlessly handle installing and uninstalling packages.
  - <u>Important Detail about `npm`</u>: The `npm` packet manager for `JavaScript` is the analog thing as a **virtual environment** in `python`!
    - <u>Quelle</u>: See the last answer on [this Stack-Overflow](https://stackoverflow.com/questions/47272966/is-installing-nodejs-packages-locally-equivalent-to-pythons-virtualenv/47284674) thread.
- **Usability Testing**: Suche jemand, der deine Webseite austestet, die du gerade konstruiert hast. Er soll dir ein ehrliches Feedback geben.
  <u>Wichtig</u>: We test the Site, not the user. It is important that the user knows, that he is not tested, but rather the website. The user can't do anything wrong. 

## Image-Management

A website's browser has the task of downloading those images when it reads an HTML-document. 

<mark>Most of the time, images are the entities that need the most time to load on a website, which is why a site with _many_ images can have a big (negative) impact on the website's performance, because many images take a looot of time to load and - therefore - you will have a poor user-experience, especially on mobile</mark>.

_That's why you need a good image-management when building websites_.

<u>The following areas lead to a better image-management and - hence - better site-performance</u>:

- Caching strategies tha use CDNs
- Implement Lazy-Loading

### Cache

When using a website, the images oftentimes stay relatively "static", that is they - oftentimes - *do not change over time*. This fact - that the image-content does almost never change over time - can be exploited in order to dimish loading-time significantly with the help of a cache-strategy. 

#### The Problem 

By storing the images on our website's server (VTX), the user's browser will have to always make requests. Because I have many images, we have _a lot of image-requests per page_ that the user renders on his phone. Hence, the loading time takes long. 

#### The theoretical Solution

<mark>It would be much more efficient - from a performance // loading perspective - if the user had those images already stored in their computer's internal (cache) memory. This is where CDNs come into play: those are servers that are distributed all across the globe and that</mark>: 

1) Visit our website.
2) Then cache // store the images on their server, _which is close to the user, from a <u>geographical</u> standpoint_.

When a user visit our website, the requests for images will be forwarded to the (geographically, much more close the user) CDNs that will already have downloaded the images of our site.

_This results in a much faster loading-time of our website and an increase in the user's experience._

#### The practical Solution

In order to use a CDN, I recommend this website as a tool to implement a caching-strategy:

- https://imagekit.io/


### Lazy-Loading

#### The Problem 

When you code an HTML-page and you include a bunch of images, you will have to tell the browser, on which path the images can be loaded via the `src`-atribute of the `<img>`-tag. 

_However - IF you have many `<img src=....>`-tags on your site - the browser will **automatically load them all at once**. And because loading image-entities is one of the most slow process when it comes to make everything visible on the user's browser, having lot's of images can take a long time to load. More specifically, **IF a user directly follows a link to another page on our site**, having downloaded all the pages is very inefficient, since the website-visitor will not have seen those images that are at the bottom of the site._

#### The theoretical Solution 

With JavaScript, we can change the behavior of how load `<img src="...">`-tags. 
**In lazy-loading**, we can tell the browser - with the help of some JavaScript code - that it only needs to load the images, that are visible in the user's viewport // browser-window (= visible portion of the screen). 

*This way, all the images that are on the bottom of our pages, will NEVER be loaded, if the user clicks on a link at the TOP of our page*.

#### The practical Solution

Use the code - which is **written in vanilla JavaScript** - from [this Fireship Youtube-Video](https://www.youtube.com/watch?v=aUjBvuUdkhg) to make Lazy-Loading possible.

## How Front-End &amp; Backend work together

- <u>Very good example &amp; explanations</u>: https://dev.to/gbudjeakp/how-to-connect-your-client-side-to-your-server-side-using-node-and-express-2i71

## How to build and think about an Application

- <u>Very good example (read the section "App Structure"): https://dev.to/gbudjeakp/how-to-make-applications-from-scratch-without-tutorials-for-beginners-26bg